---
id: usaco-1285
source: USACO Gold 2023 January
title: Moo Route
author: Aakash Gokhale
---

[Official Analysis (Python)](http://www.usaco.org/index.php?page=viewproblem2&cpid=1283)

## Solution

Notice that a[i] will always be even since we need to cross back to get back to $0$.
So we can break each cross into pairs of $2$ which representing crossing to the left and them coming back.

Let $dp[i]$ be the answer for the first $i$ numbers in the array. We can think about constructing paths in the dp. Intitially, for the first element, the paths look like below:

usaco-1283/first.png

There are $2$ cases when we are transitioning from $dp[i]$ to $dp[i + 1]$.

1. $a[i] > a[i + 1]$
In this case we simply need to choose some paths to extend and will get something like the picture below:

usaco-1283/second.png

There will be ${\frac{a[i]}{2} \choose \frac{a[i + 1]}{2}}$ ways to choose some paths to extend. Note that we had to divide by $2$ because all the paths come in pairs.

2. $a[i] < a[i + 1]$
In this case we will have to extend all of the paths but we will have some extras left over. In this case we need to split some paths into many paths as shown below.

usaco-1283/third.png

Note that we can actually split a path into many different paths even if the above diagram only shows $2$.
We can also think about this as inserting extra paths in between an already formed path.
Each extra path can be inserted in any of the extended paths. Also since the paths are non-distinct, we can use stars and bars to count the number of ways to insert them.

[Stars are bars](https://artofproblemsolving.com/wiki/index.php/Ball-and-urn) tells us that the number of ways to seperate $n$ indistinguishable items into $k$ distinguishable groups is $n + k - 1 \choose k - 1$.

So, the number of ways to split $\frac{a[i + 1}{2} - \frac{a[i]}{2}$ extra paths into $\frac{a[i]}{2}$ groups (that are potentially empty) is ${\frac{a[i + 1]}{2} - \frac{a[i]}{2} + \frac{a[i]}{2} - 1} \choose {frac{a[i]}{2} - 1}$.

This minimizes the number of turns because the only times the turns happen are:
1. at the beginning or the end of the array when they turn to go the other way
2. when there are not enoughs paths so that all of them can be extended
3. when there are too many paths such that it is necessary to cause a turn to make this path fit

## Implementation

**Time Complexity:** $\mathcal{O}(N + A + \log(P))$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

const long long MOD = 1e9 + 7;
const int MAXN = 1e6;

// BeginCodeSnip{Combinatorics Functions (from module)}
long long fac[MAXN + 1];
long long inv[MAXN + 1];

/** Computes x^y modulo p in O(log p) time. */
long long exp(long long x, long long y, long long p) {
	long long res = 1;
	x %= p;
	while (y != 0) {
		if (y % 2 == 1) {
			res *= x;
			res %= p;
		}
		x *= x;
		x %= p;
		y >>= 1;
	}
	return res;
}

/** Precomputes n! from 0 to MAXN. */
void factorial(long long p) {
	fac[0] = 1;
	for (int i = 1; i <= MAXN; i++) { fac[i] = fac[i - 1] * i % p; }
}

/**
 * Precomputes all modular inverse factorials from 0 to MAXN
 * in O(n + log p) time
 */
void inverses(long long p) {
	inv[MAXN] = exp(fac[MAXN], p - 2, p);
	for (int i = MAXN; i >= 1; i--) { inv[i - 1] = inv[i] * i % p; }
}

/** Computes nCr mod p */
long long choose(long long n, long long r, long long p) {
	return fac[n] * inv[r] % p * inv[n - r] % p;
}
// EndCodeSnip

int main() {
	// Do some precalculations
	factorial(MOD);
	inverses(MOD);

	int n;
	cin >> n;
	vector<long long> a(n);
	for (long long &i : a) { cin >> i; }

	vector<long long> dp(n);
	dp[0] = 1;
	for (int i = 1; i < n; i++) {
		if (a[i] <= a[i - 1]) {
			dp[i] = dp[i - 1] * choose(a[i - 1] / 2, a[i] / 2, MOD) % MOD;
		} else {
			long long ways = choose(a[i - 1] / 2 - 1 + (a[i] - a[i - 1]) / 2,
			                        a[i - 1] / 2 - 1, MOD);
			dp[i] = dp[i - 1] * ways % MOD;
		}
	}

	cout << dp[n - 1] << endl;
}
```

</CPPSection>

</LanguageSection>

</Spoiler>
